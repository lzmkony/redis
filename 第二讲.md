# redis 讲义
## redis 第二课 常用的五种数据结构及其底层编码方式
### 第一节常用的五种数据格式(从使用者的角度,这一层面也是Redis暴露给外部的调用接口)
具体的实现t_string.c, t_list.c, t_set.c, t_hash.c, t_zset.c
这里面包含所有具体redis命令的实现
1. KV(STRING) REDIS_STRING
2. LIST REDIS_LIST
3. SET REDIS_SET
4. HASHTABLE REDIS_HASH
5. SORTEDSET REDIS_ZSET

### 第二节五种数据格式的底层编码
1. REDIS_STRING
    OBJ_ENCODING_INT（略）
    OBJ_ENCODING_EMBSTR（详情见下OBJ_ENCODING_RAW）
    OBJ_ENCODING_RAW（sdshdrX sdsnewlen, sdsMakeRoomFor）

2. REDIS_LIST(当前版本只支持OBJ_ENCODING_QUICKLIST)
    OBJ_ENCODING_LINKEDLIST(不再使用)
    OBJ_ENCODING_QUICKLIST（quicklist）

3. REDIS_SET
    OBJ_ENCODING_INTSET
    OBJ_ENCODING_ZIPLIST
    OBJ_ENCODING_HT

4. HASHTABLE
    OBJ_ENCODING_ZIPLIST
    OBJ_ENCODING_HT

5. SORTEDSET
    OBJ_ENCODING_ZIPLIST
    OBJ_ENCODING_SKIPLIST

#define OBJ_ENCODING_RAW 0     /* Raw representation */
#define OBJ_ENCODING_INT 1     /* Encoded as integer */
#define OBJ_ENCODING_HT 2      /* Encoded as hash table */
#define OBJ_ENCODING_ZIPMAP 3  /* Encoded as zipmap */
#define OBJ_ENCODING_LINKEDLIST 4 /* No longer used: old list encoding. */
#define OBJ_ENCODING_ZIPLIST 5 /* Encoded as ziplist */
#define OBJ_ENCODING_INTSET 6  /* Encoded as intset */
#define OBJ_ENCODING_SKIPLIST 7  /* Encoded as skiplist */
#define OBJ_ENCODING_EMBSTR 8  /* Embedded sds string encoding */
#define OBJ_ENCODING_QUICKLIST 9 /* Encoded as linked list of ziplists */
#define OBJ_ENCODING_STREAM 10 /* Encoded as a radix tree of listpacks */

### 第三节查询对象使用的底层编码方式
OBJECT
OBJECT ENCODING <key> 返回给定 key 锁储存的值所使用的内部表示(representation)。
实现(object.c):
char *strEncoding(int encoding) {
    switch(encoding) {
    case OBJ_ENCODING_RAW: return "raw";
    case OBJ_ENCODING_INT: return "int";
    case OBJ_ENCODING_HT: return "hashtable";
    case OBJ_ENCODING_QUICKLIST: return "quicklist";
    case OBJ_ENCODING_ZIPLIST: return "ziplist";
    case OBJ_ENCODING_INTSET: return "intset";
    case OBJ_ENCODING_SKIPLIST: return "skiplist";
    case OBJ_ENCODING_EMBSTR: return "embstr";
    default: return "unknown";
    }
}


### 第四节如何学习操作命令详情
server.c
redisCommandTable
指出所有前端操作命令，以此为入口断点研究命令详情

### 第五节编码方式的切换
object.c
create开头的函数
free开头的函数

String
object.c
#define OBJ_ENCODING_EMBSTR_SIZE_LIMIT 44
robj *createStringObject(const char *ptr, size_t len) {
    if (len <= OBJ_ENCODING_EMBSTR_SIZE_LIMIT)
        return createEmbeddedStringObject(ptr,len);
    else
        return createRawStringObject(ptr,len);
}

robj *tryObjectEncoding(robj *o)

void freeHashObject(robj *o) {
    switch (o->encoding) {
    case OBJ_ENCODING_HT:
        dictRelease((dict*) o->ptr);
        break;
    case OBJ_ENCODING_ZIPLIST:
        zfree(o->ptr);
        break;
    default:
        serverPanic("Unknown hash encoding type");
        break;
    }
}

void freeZsetObject(robj *o) {
    zset *zs;
    switch (o->encoding) {
    case OBJ_ENCODING_SKIPLIST:
        zs = o->ptr;
        dictRelease(zs->dict);
        zslFree(zs->zsl);
        zfree(zs);
        break;
    case OBJ_ENCODING_ZIPLIST:
        zfree(o->ptr);
        break;
    default:
        serverPanic("Unknown sorted set encoding");
    }
}


List
t_list.c
pushGenericCommand(c,LIST_HEAD);

robj *createQuicklistObject(void) {
    quicklist *l = quicklistCreate();
    robj *o = createObject(OBJ_LIST,l);
    o->encoding = OBJ_ENCODING_QUICKLIST;
    return o;
}

SET
t_set.c
robj *setTypeCreate(sds value) {
    if (isSdsRepresentableAsLongLong(value,NULL) == C_OK)
        return createIntsetObject();
    return createSetObject();
}
setTypeConvert(subject,OBJ_ENCODING_HT);

HASHTABLE
开始：
robj *createHashObject(void) {
    unsigned char *zl = ziplistNew();
    robj *o = createObject(OBJ_HASH, zl);
    o->encoding = OBJ_ENCODING_ZIPLIST;
    return o;
}

切换：
void hashTypeTryConversion(robj *o, robj **argv, int start, int end) {
    int i;

    if (o->encoding != OBJ_ENCODING_ZIPLIST) return;

    for (i = start; i <= end; i++) {
        if (sdsEncodedObject(argv[i]) &&
            sdslen(argv[i]->ptr) > server.hash_max_ziplist_value)
        {
            hashTypeConvert(o, OBJ_ENCODING_HT);
            break;
        }
    }
}

hashTypeConvert(o, OBJ_ENCODING_HT);
只会向上切换，不会向下切换，但Hashtable会进行rehash

ZSET
OBJ_ZSET_MAX_ZIPLIST_VALUE ---- 默认：64
OBJ_ZSET_MAX_ZIPLIST_ENTRIES ---- 默认：128

if (server.zset_max_ziplist_entries == 0 ||
    server.zset_max_ziplist_value < sdslen(c->argv[scoreidx+1]->ptr))
{
    zobj = createZsetObject();
} else {
    zobj = createZsetZiplistObject();
}
dbAdd(c->db,key,zobj);
